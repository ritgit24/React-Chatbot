package handlers

import (
	
	"chatbot-backend/models"
	"chatbot-backend/utility"
	"encoding/json"

	"log"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/go-resty/resty/v2"
	"gorm.io/gorm"
)

type groqResponse struct {
	Choices []struct {
		Message struct {
			Content string `json:"content"`
		} `json:"message"`
	} `json:"choices"`
}

// the func GettingQueriesAnswer handles chatbot requests
func GettingQueriesAnswer(db *gorm.DB, sessionSecretKey, groqApiKey string) func(c *gin.Context) {
	return func(c *gin.Context) {
		// Retrieve the session token from cookies
		toDecode, err := c.Request.Cookie(sessionSecretKey)
		if err != nil {
			log.Printf("Error getting sessionToken: %v\n", err)
			c.JSON(http.StatusBadRequest, gin.H{"message": "error getting sessionToken", "error": err.Error()})
			return
		}

		// Decoding the session token
		decoded, err := utility.DecodingToken(toDecode.Value, sessionSecretKey)
		if err != nil {
			log.Printf("Error decoding token: %v\n", err)
			c.JSON(http.StatusUnauthorized, gin.H{"message": "invalid session token", "error": err.Error()})
			return
		}

		// Retrieve the session from the database
		var session models.Session
		if err := db.Where("id = ?", decoded["sessionid"]).First(&session).Error; err != nil {
			log.Printf("Error retrieving session: %v\n", err)
			c.JSON(http.StatusInternalServerError, gin.H{"message": "unable to retrieve session", "error": err.Error()})
			return
		}

		// Parse the request body
		var payload []map[string]string
		if err := c.BindJSON(&payload); err != nil {
			log.Printf("Error parsing request body: %v\n", err)
			c.JSON(http.StatusBadRequest, gin.H{"message": "error getting body request", "error": err.Error()})
			return
		}

		// Update the session title with the first user message
		if len(payload) > 0 {
			db.Model(&session).Update("session_title", payload[0]["content"])
		}

		// Send the payload to the Groq API
		client := resty.New()
		resp, err := client.R().
			SetHeader("Authorization", "Bearer "+groqApiKey).
			SetHeader("Content-Type", "application/json").
			SetBody(map[string]interface{}{
				"model":    "llama-3.1-8b-instant",
				"messages": payload,
			}).
			Post("https://api.groq.com/openai/v1/chat/completions")
		if err != nil {
			log.Printf("Error calling Groq API: %v\n", err)
			c.JSON(http.StatusInternalServerError, gin.H{"message": "Can't generate response from LLM", "error": err.Error()})
			return
		}

		// Parse the Groq API response
		//When you interact with the Groq API, it returns a response that typically contains the output generated by
		// the model, along with metadata about the request. Parsing the Groq API response involves extracting meaningful 
		// information from this structured data.
		//{
//   "choices": [
//     {
//       "message": {
//         "role": "assistant",
//         "content": "Hello! How can I assist you today?"
//       },
//       "finish_reason": "stop",
//       "index": 0
//     }
//   ],
//   "usage": {
//     "prompt_tokens": 10,
//     "completion_tokens": 8,
//     "total_tokens": 18
//   },
//   "created": 1698256345,
//   "id": "chatcmpl-12345",
//   "model": "mixtral-8x7b-32768",
//   "object": "chat.completion"
// }
		//
		var groqResponse groqResponse
		if err := json.Unmarshal(resp.Body(), &groqResponse); err != nil {
			log.Printf("Error parsing Groq API response: %v\n", err)
			c.JSON(http.StatusInternalServerError, gin.H{"message": "Error parsing LLM response", "error": err.Error()})
			return
		}

		// Update the session context with the new conversation
		context := append(payload, map[string]string{
			"role":    "assistant",
			"content": groqResponse.Choices[0].Message.Content,
		})

		// Convert context to JSON
		jsonContext, err := json.Marshal(context)//Converts the context object (e.g., a struct, map, or slice) into a JSON-encoded byte slice ([]byte).
        // If context is a struct, it uses the struct's field tags (e.g., json:"field_name") to determine the JSON keys.
		if err != nil {
			log.Printf("Error marshaling context: %v\n", err)
			c.JSON(http.StatusInternalServerError, gin.H{"message": "Error updating session context", "error": err.Error()})
			return
		}
        //The code snippet above is for converting a context object (likely a Go struct or map) into a JSON string using json.Marshal. This is useful when we need to store or transmit structured data in a text-based format like JSON.

		// Save the updated context to the database
		db.Model(&session).Update("context", jsonContext)

		// Return the chatbot's response
		c.JSON(http.StatusOK, gin.H{
			"message":    "Added new prompt in the database",
			"llmResponse": groqResponse.Choices[0].Message.Content,
		})
	}
}